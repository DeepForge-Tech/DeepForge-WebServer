<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded HTTP Server: http Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded HTTP Server
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">http Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace with scope for all Embedded HTTP Server definitions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a871a35713a39ae3b231aeb4cf7a2a909"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(std::ostream &amp;, <a class="el" href="namespacehttp.html#a75ae3de7ca7b133dac7768cad4fcc680">connection_event</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#a871a35713a39ae3b231aeb4cf7a2a909">connection_callback_type</a></td></tr>
<tr class="separator:a871a35713a39ae3b231aeb4cf7a2a909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402f3043ab3c30016f59a05f3c8986ff"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(std::ostream &amp;, const std::string &amp;, const std::string &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#a402f3043ab3c30016f59a05f3c8986ff">get_action_type</a></td></tr>
<tr class="separator:a402f3043ab3c30016f59a05f3c8986ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0a98025d0cad40781e0c6d21c93dc3"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(std::ostream &amp;, const std::string &amp;, const std::string &amp;, std::istream &amp;, std::size_t, const std::string &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#a4b0a98025d0cad40781e0c6d21c93dc3">post_action_type</a></td></tr>
<tr class="separator:a4b0a98025d0cad40781e0c6d21c93dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ea6b23cfb82a3066d0da3c890c5176"><td class="memItemLeft" align="right" valign="top"><a id="a94ea6b23cfb82a3066d0da3c890c5176"></a>
typedef std::unordered_map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#a94ea6b23cfb82a3066d0da3c890c5176">params_map_type</a></td></tr>
<tr class="memdesc:a94ea6b23cfb82a3066d0da3c890c5176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of map {key-&gt;value,...} for decoding URL and form parameters. <br /></td></tr>
<tr class="separator:a94ea6b23cfb82a3066d0da3c890c5176"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a75ae3de7ca7b133dac7768cad4fcc680"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#a75ae3de7ca7b133dac7768cad4fcc680">connection_event</a> { <a class="el" href="namespacehttp.html#a75ae3de7ca7b133dac7768cad4fcc680a4237ba31caa61bce3dbfe28f8b0ad990">just_connected</a>, 
<a class="el" href="namespacehttp.html#a75ae3de7ca7b133dac7768cad4fcc680a2532075421255127be8e56ac7a275c19">to_be_closed</a>
 }</td></tr>
<tr class="memdesc:a75ae3de7ca7b133dac7768cad4fcc680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type defining possible connection events, used to notify the connection callback.  <a href="namespacehttp.html#a75ae3de7ca7b133dac7768cad4fcc680">More...</a><br /></td></tr>
<tr class="separator:a75ae3de7ca7b133dac7768cad4fcc680"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae84f82921256993821ed84d581c5503a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#ae84f82921256993821ed84d581c5503a">server_start</a> (int port_number, const char *base_directory)</td></tr>
<tr class="memdesc:ae84f82921256993821ed84d581c5503a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the embedded HTTP server.  <a href="#ae84f82921256993821ed84d581c5503a">More...</a><br /></td></tr>
<tr class="separator:ae84f82921256993821ed84d581c5503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ec8572bfb62699e9301d495f7803bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#a47ec8572bfb62699e9301d495f7803bb">register_connection_callback</a> (<a class="el" href="namespacehttp.html#a871a35713a39ae3b231aeb4cf7a2a909">connection_callback_type</a> callback)</td></tr>
<tr class="separator:a47ec8572bfb62699e9301d495f7803bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9af30722c758a4defa980806f3df187"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#af9af30722c758a4defa980806f3df187">register_generic_get_action</a> (const char *name, <a class="el" href="namespacehttp.html#a402f3043ab3c30016f59a05f3c8986ff">get_action_type</a> f)</td></tr>
<tr class="separator:af9af30722c758a4defa980806f3df187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc03b20b444f31f3bbc3bc1792d0bd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#accc03b20b444f31f3bbc3bc1792d0bd6">register_html_get_action</a> (const char *name, <a class="el" href="namespacehttp.html#a402f3043ab3c30016f59a05f3c8986ff">get_action_type</a> f)</td></tr>
<tr class="separator:accc03b20b444f31f3bbc3bc1792d0bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68abbabf80ce6d79d036b0bb1ee6461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#ab68abbabf80ce6d79d036b0bb1ee6461">register_text_get_action</a> (const char *name, <a class="el" href="namespacehttp.html#a402f3043ab3c30016f59a05f3c8986ff">get_action_type</a> f)</td></tr>
<tr class="separator:ab68abbabf80ce6d79d036b0bb1ee6461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd4fa4f44b830b3f9642d7d74be2c1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#adcd4fa4f44b830b3f9642d7d74be2c1d">register_generic_post_action</a> (const char *name, <a class="el" href="namespacehttp.html#a4b0a98025d0cad40781e0c6d21c93dc3">post_action_type</a> f)</td></tr>
<tr class="separator:adcd4fa4f44b830b3f9642d7d74be2c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d202bfac95f94f86350b01be0e4bde3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#a7d202bfac95f94f86350b01be0e4bde3">register_html_post_action</a> (const char *name, <a class="el" href="namespacehttp.html#a4b0a98025d0cad40781e0c6d21c93dc3">post_action_type</a> f)</td></tr>
<tr class="separator:a7d202bfac95f94f86350b01be0e4bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa8d35ec01f81aedc46bac206b04d43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#a2fa8d35ec01f81aedc46bac206b04d43">register_text_post_action</a> (const char *name, <a class="el" href="namespacehttp.html#a4b0a98025d0cad40781e0c6d21c93dc3">post_action_type</a> f)</td></tr>
<tr class="separator:a2fa8d35ec01f81aedc46bac206b04d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6beb1ae5c29be78928f05260e84c63c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#af6beb1ae5c29be78928f05260e84c63c">html_encode</a> (const std::string &amp;s)</td></tr>
<tr class="separator:af6beb1ae5c29be78928f05260e84c63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9456d34763556829c058ab1d80e61aaf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#a9456d34763556829c058ab1d80e61aaf">url_encode</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a9456d34763556829c058ab1d80e61aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24b4d643b11bd3167390696397a55af"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#af24b4d643b11bd3167390696397a55af">url_decode</a> (const std::string &amp;s)</td></tr>
<tr class="separator:af24b4d643b11bd3167390696397a55af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaec6680232fd5e16ee1b6751d77b707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehttp.html#a94ea6b23cfb82a3066d0da3c890c5176">params_map_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#afaec6680232fd5e16ee1b6751d77b707">decode_params</a> (const std::string &amp;params, bool decode)</td></tr>
<tr class="separator:afaec6680232fd5e16ee1b6751d77b707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487929c6a392d7d2d4e636b4777d5f9b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#a487929c6a392d7d2d4e636b4777d5f9b">header</a> (const std::string &amp;mime_type, std::size_t content_length=0, bool cache=false)</td></tr>
<tr class="separator:a487929c6a392d7d2d4e636b4777d5f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa556b0ab0092994b4fc68f7f9b3745ac"><td class="memItemLeft" align="right" valign="top"><a id="aa556b0ab0092994b4fc68f7f9b3745ac"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehttp.html#aa556b0ab0092994b4fc68f7f9b3745ac">log_connections</a> = 0x01</td></tr>
<tr class="memdesc:aa556b0ab0092994b4fc68f7f9b3745ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit masks for various categories of diagnostic log messages. <br /></td></tr>
<tr class="separator:aa556b0ab0092994b4fc68f7f9b3745ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace with scope for all Embedded HTTP Server definitions. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a871a35713a39ae3b231aeb4cf7a2a909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871a35713a39ae3b231aeb4cf7a2a909">&#9670;&nbsp;</a></span>connection_callback_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(std::ostream &amp;, <a class="el" href="namespacehttp.html#a75ae3de7ca7b133dac7768cad4fcc680">connection_event</a>)&gt; <a class="el" href="namespacehttp.html#a871a35713a39ae3b231aeb4cf7a2a909">http::connection_callback_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of function callback for connection event notifications. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>stream object that is the subject of the current event. </td></tr>
    <tr><td class="paramname">event</td><td>the name of current event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a402f3043ab3c30016f59a05f3c8986ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402f3043ab3c30016f59a05f3c8986ff">&#9670;&nbsp;</a></span>get_action_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(std::ostream &amp;, const std::string &amp;, const std::string &amp;)&gt; <a class="el" href="namespacehttp.html#a402f3043ab3c30016f59a05f3c8986ff">http::get_action_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of function callback for handling GET requests. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>stream object handling the requesting client connection </td></tr>
    <tr><td class="paramname">path</td><td>name of the requested resource (up to the '?' sign, if any) </td></tr>
    <tr><td class="paramname">params</td><td>the URL parameters (from the '?' sign to the end of URL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b0a98025d0cad40781e0c6d21c93dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0a98025d0cad40781e0c6d21c93dc3">&#9670;&nbsp;</a></span>post_action_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(std::ostream &amp;, const std::string &amp;, const std::string &amp;, std::istream &amp;, std::size_t, const std::string &amp;)&gt; <a class="el" href="namespacehttp.html#a4b0a98025d0cad40781e0c6d21c93dc3">http::post_action_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of function callback for handling POST requests. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>stream object handling the output part of the requesting client connection </td></tr>
    <tr><td class="paramname">path</td><td>name of the requested resource (up to the '?' sign, if any) </td></tr>
    <tr><td class="paramname">params</td><td>the URL parameters (from the '?' sign to the end of URL) </td></tr>
    <tr><td class="paramname">in</td><td>stream object handling the input part of the requesting connection </td></tr>
    <tr><td class="paramname">content_length</td><td>number of bytes to be consumed from the in stream </td></tr>
    <tr><td class="paramname">mime_type</td><td>MIME type declared for the POST request by the client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a75ae3de7ca7b133dac7768cad4fcc680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ae3de7ca7b133dac7768cad4fcc680">&#9670;&nbsp;</a></span>connection_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehttp.html#a75ae3de7ca7b133dac7768cad4fcc680">http::connection_event</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type defining possible connection events, used to notify the connection callback. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a75ae3de7ca7b133dac7768cad4fcc680a4237ba31caa61bce3dbfe28f8b0ad990"></a>just_connected&#160;</td><td class="fielddoc"><p>The given stream (client connection) was just created. </p>
</td></tr>
<tr><td class="fieldname"><a id="a75ae3de7ca7b133dac7768cad4fcc680a2532075421255127be8e56ac7a275c19"></a>to_be_closed&#160;</td><td class="fielddoc"><p>The given stream is to be closed and destroyed. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afaec6680232fd5e16ee1b6751d77b707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaec6680232fd5e16ee1b6751d77b707">&#9670;&nbsp;</a></span>decode_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacehttp.html#a94ea6b23cfb82a3066d0da3c890c5176">params_map_type</a> http::decode_params </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decode URL or form parameters.</p>
<p>Decode URL or form parameters into map. The encoded parameters are expected to have the "key1=value1&amp;key2=value2&amp;..." format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>parameters, stored as a single string, to be decoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded parameter map. </dd></dl>

</div>
</div>
<a id="a487929c6a392d7d2d4e636b4777d5f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487929c6a392d7d2d4e636b4777d5f9b">&#9670;&nbsp;</a></span>header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string http::header </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mime_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>content_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cache</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate basic HTTP header.</p>
<p>Generate basic HTTP header, typically for the generic resource handler, of the form: HTTP/1.1 200 OK Content-Type: mime_type Content-Length: content_length Cache-Control: ...</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mime_type</td><td>MIME type declaration. </td></tr>
    <tr><td class="paramname">content_length</td><td>number of bytes in the response body. </td></tr>
    <tr><td class="paramname">cache</td><td>whether the given response is supposed to be cached </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generated HTTP header. </dd></dl>

</div>
</div>
<a id="af6beb1ae5c29be78928f05260e84c63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6beb1ae5c29be78928f05260e84c63c">&#9670;&nbsp;</a></span>html_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string http::html_encode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encode basic HTML entities.</p>
<p>Encode basic HTML entities - '&lt;', '&gt;', '&amp;'. Those special characters are replaced with "&amp;lt;", "&amp;gt;" and "&amp;amp;". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be encoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encoded string. </dd></dl>

</div>
</div>
<a id="a47ec8572bfb62699e9301d495f7803bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ec8572bfb62699e9301d495f7803bb">&#9670;&nbsp;</a></span>register_connection_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void http::register_connection_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehttp.html#a871a35713a39ae3b231aeb4cf7a2a909">connection_callback_type</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register the connection callback.</p>
<p>Register the connection callback. The callback function will be notified whenever the client connection is created to is about to be destroyed. The previous callback registration (if any) is replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>the callback function to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9af30722c758a4defa980806f3df187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9af30722c758a4defa980806f3df187">&#9670;&nbsp;</a></span>register_generic_get_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void http::register_generic_get_action </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehttp.html#a402f3043ab3c30016f59a05f3c8986ff">get_action_type</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register generic GET handler.</p>
<p>Register generic GET handler. The generic handler is responsible for producing the whole response, including HTTP headers, and for flushing the output stream.</p>
<p>Note: generic actions are called in the context of the thread that is dedicated for the given connection and the stream object retains state between invocations (it directly represents the connection stream).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the "resource" to be handled by the callback. </td></tr>
    <tr><td class="paramname">f</td><td>function callback that will handle the GET request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcd4fa4f44b830b3f9642d7d74be2c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd4fa4f44b830b3f9642d7d74be2c1d">&#9670;&nbsp;</a></span>register_generic_post_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void http::register_generic_post_action </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehttp.html#a4b0a98025d0cad40781e0c6d21c93dc3">post_action_type</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register generic POST handler.</p>
<p>Register generic POST handler. The generic handler is responsible for producing the whole response, including HTTP headers.</p>
<p>Note: generic actions are called in the context of the thread that is dedicated for the given connection and the stream object retains state between invocations (it directly represents the connection stream).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the "resource" to be handled by the callback. </td></tr>
    <tr><td class="paramname">f</td><td>function callback that will handle the POST request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accc03b20b444f31f3bbc3bc1792d0bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc03b20b444f31f3bbc3bc1792d0bd6">&#9670;&nbsp;</a></span>register_html_get_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void http::register_html_get_action </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehttp.html#a402f3043ab3c30016f59a05f3c8986ff">get_action_type</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register text/html GET handler.</p>
<p>Register text/html GET handler. The text/html handler is responsible for producing only the response data, the HTTP headers are taken care of automatically.</p>
<p>Note: the text/html action is called in the context of the thread that is dedicated for the given connection, but the stream object is temporary and does not retain state between invocations. The collected output is automatically flushed to the actual connection stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the "resource" to be handled by the callback. </td></tr>
    <tr><td class="paramname">f</td><td>function callback that will handle the GET request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d202bfac95f94f86350b01be0e4bde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d202bfac95f94f86350b01be0e4bde3">&#9670;&nbsp;</a></span>register_html_post_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void http::register_html_post_action </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehttp.html#a4b0a98025d0cad40781e0c6d21c93dc3">post_action_type</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register text/html POST handler.</p>
<p>Register text/html POST handler. The text/html handler is responsible for producing only the response data, the HTTP headers are taken care of automatically.</p>
<p>Note: the text/html action is called in the context of the thread that is dedicated for the given connection, but the stream object is temporary and does not retain state between invocations. The collected output is automatically flushed to the actual connection stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the "resource" to be handled by the callback. </td></tr>
    <tr><td class="paramname">f</td><td>function callback that will handle the POST request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab68abbabf80ce6d79d036b0bb1ee6461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68abbabf80ce6d79d036b0bb1ee6461">&#9670;&nbsp;</a></span>register_text_get_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void http::register_text_get_action </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehttp.html#a402f3043ab3c30016f59a05f3c8986ff">get_action_type</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register text/plain GET handler.</p>
<p>Register text/plain GET handler. The text/plain handler is responsible for producing only the response data, the HTTP headers are taken care of automatically.</p>
<p>Note: the text/plain action is called in the context of the thread that is dedicated for the given connection, but the stream object is temporary and does not retain state between invocations. The collected output is automatically flushed to the actual connection stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the "resource" to be handled by the callback. </td></tr>
    <tr><td class="paramname">f</td><td>function callback that will handle the GET request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fa8d35ec01f81aedc46bac206b04d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa8d35ec01f81aedc46bac206b04d43">&#9670;&nbsp;</a></span>register_text_post_action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void http::register_text_post_action </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehttp.html#a4b0a98025d0cad40781e0c6d21c93dc3">post_action_type</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register text/plain POST handler.</p>
<p>Register text/plain POST handler. The text/plain handler is responsible for producing only the response data, the HTTP headers are taken care of automatically.</p>
<p>Note: the text/plain action is called in the context of the thread that is dedicated for the given connection, but the stream object is temporary and does not retain state between invocations. The collected output is automatically flushed to the actual connection stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the "resource" to be handled by the callback. </td></tr>
    <tr><td class="paramname">f</td><td>function callback that will handle the POST request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae84f82921256993821ed84d581c5503a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84f82921256993821ed84d581c5503a">&#9670;&nbsp;</a></span>server_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void http::server_start </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>base_directory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the embedded HTTP server. </p>
<p>Start the singleton embedded HTTP server. The server creates the listener socket and operates it in the context of the calling thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_number</td><td>port number for the listening socket </td></tr>
    <tr><td class="paramname">base_directory</td><td>directory containing static files. </td></tr>
    <tr><td class="paramname">error_log</td><td>optional output stream for diagnostic logs </td></tr>
    <tr><td class="paramname">log_events_mask</td><td>bit mask for selecting active categories of log messages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function does not return as long as the server functions properly. </dd></dl>

</div>
</div>
<a id="af24b4d643b11bd3167390696397a55af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24b4d643b11bd3167390696397a55af">&#9670;&nbsp;</a></span>url_decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string http::url_decode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decode part of the URL (used for parameters).</p>
<p>Decode part of the URL, using reverse logic of url_encode. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be decoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded string. </dd></dl>

</div>
</div>
<a id="a9456d34763556829c058ab1d80e61aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9456d34763556829c058ab1d80e61aaf">&#9670;&nbsp;</a></span>url_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string http::url_encode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encode string for safe use within URL.</p>
<p>Encode string for safe use within URL. Alpha-numeric characters, with '-', '_', '.' and '~' are left unchanged, other characters are encoded as hh hex code (space is replaced with '+'). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to be encoded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>encoded string. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
